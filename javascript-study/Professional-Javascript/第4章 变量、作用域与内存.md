## 1 原始值和引用值

原始值就是简单数据（除去对象的6种类型）——栈内存；引用值就是由多个值构成的对象——堆内存；前置按值访问，后者按引用访问；很多语言字符串用对象，ECMAScript种则是按值访问

- **动态属性**：1）只有引用值可以有动态属性（创建、修改），原始值可以添加属性不报错但是毫无意义；2）引用值需要使用new关键字，原始值使用原始字面量就行，用new也可以但结果相同

- **复制值**：1）通过原始值变量赋值另一个变量，会复制到新变量位置，二者独立；2）引用值复制举止复制指针，两个变量也是独立的，只不过指向同一个对象操作上处理的是同一块数据

- **传递参数**：所有参数按值传递，参数的值（对象的值就是对象地址）会复制到一个函数的一个局部变量中；传入对象地址操控对象，看起来像是按应用传参，具体看下面代码。（重新赋值对象和命名的操作是没有意义的，总之把当成传递指针来理解就行，）

  ```javascript
  function setName(obj) {
  	obj.name = "Nicolas";
  	obj = new Object();
  	obj.name = "Greg";
  }
  let person = new Object();
  setName(person);
  console.log(person.name); // "Nicolas"
  ```

  [^按引用传递参数]: 参数的**位置**会保存在局部变量，意味着对局部变量的修改会反映到函数外部

- **确定类型**：typeof对原始值管用，但对于对象只返回Object，想要知道具体是什么类型的对象，使用*<u>instanceof</u>*

---



## 2 执行上下文与作用域

每个函数调用都有自己的上下文；全局上下文就是最外层的上下文（浏览器中就是window对象）【我理解的上下文就是执行一段过程所需的所有要素】

上下文的代码执行中会创建变量对象的的一个作用域链，决定了访问变量和函数的顺序

有点晦涩难懂，有点像编译系统什么静态链和动态链，和符号表

- **作用域链增强**

   - 执行上下文主要有 全局上下文 和 函数上下文 和 块级上下文 三种；某些语句会导致在作用域前端临时添加一个上下文，代码执行后删除
   - 即with语句 和 try/catch语句的catch块

- **变量声明**

   1. 使用var的函数作用域声明：变量会自动添加到最近的上下文（函数中就是函数的局部上下文），未经声明就初始化的会添加到全局上下文（这样不会，严格模式会报错）；<u>**var声明会放在作用域所有代码之上，意味着可以变量申明之前使用变量，该现象叫做”提升“**</u>。

   2. 使用let的函数作用域声明：他的作用域是块，即花括号；可以简单理解为var的作用域在函数体（最大的函数就是整个窗体），let的作用域在花括号

   3. 使用const的常量声明：声明的同时必须初始化为某个是，其生命周期不能重新赋值；const常量赋值为对象，是可以修改其对象的键值（使用Object.freeze()就不能修改）

   4. 标识符查找：从最局部的上下文（块）查找，如果找到目标标识符，就停止继续引用父上下文的同名标识符。如下文

      ```javascript
      var color = 'blue';
      function getColor() {
          let color = 'red'; {
              let color = 'green';
              return color;
          }
      }
      console.log(getColor());
      ```

   ------

   

   ## 3 垃圾回收 

   周期性判定哪个变量不会使用，然后释放它占用的内存；有两种主要标记策略：标记清理 和 引用计数

- **标记清理**
- **引用计数**
- **性能**
- **内存管理**
- **解除引用**
    
    1. 使用const和let声明提升性能
    2. 隐藏类和删除操作
    3. 内存泄漏
    4. 静态分配和对象池

------



## 4 小结

- 关于垃圾回收基本没动，不想看而且对学习js没啥用，感觉知道有这么个东西就够了
- 